/*
Problem 29
Consider all integer combinations of a^b for 2 <= a <= 5 and 2 <= b <= 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 <= a <= 100 and 2 <= b <= 100?

Answer : 9183
*/

/*
TIPS:
1) Brute Force (tough in vanilla C++ since BigInt not present)

2) Factorization Approach :
the maximum number of solutions is 99*99 = 9801,
so lets find the duplicated and subtract them
from the maximum by hand.

Suppose a is a square of the smaller a, but not a
square of a square. In that case we have duplicates
when b is between 2-50, a total of 49 times. This
happens for the numbers 4, 9, 25, 36, 49, 100 since
4 is a square of 2, and thus 42 = (22)2 = 222, and so on.
So 6 a’s which each has 40 duplicates. A total
of 649 = 294 duplicates.

The reason 16 and 81 is not mentioned, is the
condition that we need a number which is not a
square of a square.

Same deduction can be made for cubes.  Suppose a
is a cube of a smaller a but not cubes of squares.
Then we have duplicates when b is between 2 and 33.
With the same deduction as above; 43 = (23)2 = 23*2
For b = 34,36,38,…, 66 we have duplicates of the
smaller a raised to 3(b/2). This gives us another
17 duplicates. So each cube gives us 32+17=49 duplicates.

This happens for the numbers; 8, 27 which have 32
duplicates each, which is a total of 98 duplicates.
The reason 64 is left out, is that it is a cube of a
square, and thus will be covered later.

Now we get the pattern, so lets check numbers which
are the 4th power of a smaller a or squares of squares
if you like.  We have two squares of squares 16 and 81.
Whenever b is between 2 and 49, we have a duplicate
for the square root of a raised to b2. And when b is
51, 54, 57, … , 75 we have duplicates of a^(3/4) 
raised to b4/3.
An example of that is 1651 = (163/4)514/3 = 868.
This gives us a total of 2(49+16) = 116 duplicates.

The same analysis can be made when a is the 5th power
of a smaller a. This happens for the number 32.
It has duplicates when b is between 2 and 20.
When b is 22, 24, 26, … , 40 we have duplicates
for (a2/5)b5/2, a total of 10 duplicates.
When b is 21, 27, 33, 39, 42, 45, 48, 51, 54, 57 , 60
we have duplicates for (a3/5)b5/3, a total of 11 duplicates.
Please note the serie is irregular as some 24, 30 and 36 are covered by previous case.
And last but not least we have duplicates for (a4/5)b*5/4 whenever b is 44, 52, 56, 64, 68, 72, 76, 80.
A total of 8 duplicates. So the number 32 produces 19+10+11+8 = 48 duplicates.

When a is the 6th power of a smaller a,
there are duplicates for the square root of
a raised to 2b. This happens for b between 2 and 50.
The we have duplicates for (a4/6)b6/4
covering 52, 54, 56, … , 66 and we have duplicates
for (a5/6)b6/5 covering 55, 65, 70, 75 , 80.
A total of  62 duplicates.

Since 27 = 128 we do not need to check higher powers.

When we sum up the identified duplicates we end up with
294+98+116+48+62=618.
Subtract this from 9801 which is the number of
possible solutions and we get the result 9801-618 = 9183.
*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
  unsigned int maxExponent = 100;

  // 2^17 > 10^5 (max. input)
  const unsigned int MaxBasePower = 16;

  // if a^b = base^(exponent*basePower)
  // then b = (1..n) but exponent*basePower = (basePower, 2*basePower, 3*basePower, ..., n*basePower)
  // store for each product exponent*basePower the smallest basePower
  vector<unsigned int> minExponent((maxExponent+1)*MaxBasePower);
  for (unsigned int i = 1; i <= MaxBasePower; i++)
    for (unsigned int j = 1; j <= maxExponent; j++)
      if (minExponent[i*j] == 0)
        minExponent[i*j] = i;

  // all "a" which can be composed as base^exponent, stored as [a] => [base]
  vector<unsigned int> base(maxExponent + 1, 0);

  // how often numbers were used multiple times (those are the collisions we are looking for)
  unsigned int repeated = 0;

  // analyze all bases
  for (unsigned int x = 2; x <= maxExponent; x++) // maximum base is maxExponent, too
  {
    // is x = parent^exponent ?
    auto parent = base[x];
    if (parent == 0) // no
    {
      // find all future children where "x" is the parent
      auto power = x * x;
      // [x^2] = [x^3] = [x^4] = ... = x
      while (power <= maxExponent)
      {
        base[power] = x;
        power *= x;
      }

      // no x=a^b possible, "repeated" remains unchanged
      continue;
    }

    // we have a parent, find exponent such that a = parent^exponent
    unsigned int exponent = 0;
    auto reduce = x;
    while (reduce > 1)
    {
      reduce /= parent;
      exponent++;
    }

    // analyze all pairs, and count all numbers we saw before (repeated++)
    for (unsigned int y = 2; y <= maxExponent; y++)
    {
      // that exponent was already used ?
      if (minExponent[y * exponent] < exponent)
        repeated++;
    }
  }

  // there are (maxExponent-1)^2 combinations, subtract all duplicates
  unsigned long long all = maxExponent - 1;
  auto result = all*all - repeated;
  cout << result << endl;
  return 0;
}
